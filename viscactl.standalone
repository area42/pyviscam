#!/usr/bin/env python


import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path, errno

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    open(os.path.join(partial_path, "__init__.py"), "w").write("\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "w") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('''pyviscam/constants.py''', '''#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\n"""\nThis file contains the constants value for camera\nFor now, these are Tandberg/Cisco, but we need a better system\nto choose the model of camera, and the constants and features only for this one\n"""\n\ncommands = {\n            \'AE_mode\':\n                {\'getcmd\'    : "\\x04\\x39",\n                 "gettype"   : "enum",\n                 "getattr"   : {0: \'auto\', 3: \'manual\'},\n                 \'setcmd\'   : "\\x01\\x04\\x39",\n                 \'settype\'  : \'enum\',\n                 \'setattr\'  : {\'auto\' : \'\\x00\',\'manual\' : \'\\x03\'}\n                },\n            \'als_bgain\':\n                {\'getcmd\'    : "\\x50\\x51",\n                 "gettype"   : "uint32"\n                },\n            \'als_ggain\':\n                {\'getcmd\'    : "\\x50\\x52",\n                 "gettype" : "uint32"\n                },\n            \'als_rgain\':\n                {\'getcmd\'    : "\\x50\\x50",\n                 "gettype" : "uint32"\n                },\n            \'als_wgain\':\n                {\'getcmd\'    : "\\x50\\x53",\n                 "gettype" : "uint32"\n                },\n            \'backlight\':\n                {\'getcmd\'    : "\\x04\\x33",\n                 "gettype" : "enum",\n                 "getattr"   : {2: \'on\', 3: \'off\', 4: \'auto\'},\n                 \'setcmd\'    : "\\x01\\x04\\x33",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'on\' : \'\\x02\',\'off\' : \'\\x03\'},\n                 \'description\': "BacklightCompensation Mode"\n                },\n            \'call_led\':\n                {\'getcmd\'   : "\\x01\\x33\\x01",\n                 "gettype"  : "enum",\n                 "getattr"  : {2: \'on\', 3: \'off\', 4: \'blink\'},\n                 \'setcmd\'   : "\\x01\\x33\\x01",\n                 \'settype\'  : \'enum\',\n                 \'setattr\'  : {\'on\' : \'\\x01\',\'off\' : \'\\x00\', \'blink\': \'\\x02\'}\n                },\n            \'debug\':\n                {\'setcmd\'   : "\\x01\\x39",\n                 \'settype\'  : \'enum\',\n                 \'setattr\'  : {\'on\' : \'\\x01\',\'off\' : \'\\x00\', }\n                },\n            \'debug_cmd\':\n                 {\'setcmd\'   : "\\xa4",\n                 \'settype\'  : \'debug\',\n                },\n            \'flip\':\n                {\'getcmd\'    : "\\x04\\x66",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: "flipped", 3: "normal"},\n                 \'setcmd\'    : "\\x01\\x04\\x66",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'flipped\' : \'\\x02\',\'normal\' : \'\\x03\', \'flip\': \'\\x02\'},\n                 \'description\': \'flip image\'\n                },\n            \'focus_mode\':\n                {\'getcmd\'    : "\\x04\\x38",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: \'auto\', 3: \'manual\'},\n                 \'setcmd\'    : "\\x01\\x04\\x38",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'auto\' : \'\\x02\',\'manual\' : \'\\x03\'},\n                 \'description\': \'Focus mode.\'\n                },\n            \'focus\':\n                {\'getcmd\'    : "\\x04\\x48",\n                 "gettype"   : "int16",\n                 \'setcmd\'    : "\\x01\\x04\\x48",\n                 \'settype\'   : \'int16\',\n                 \'setmin\'    : 4095,\n                 \'setmax\'    : 4673,\n                 \'description\':\'Focus Direct (Near: 4096.. Tele: 4672)\'\n                },\n            \'focus_ctl\':\n                {\'setcmd\'    : "\\x01\\x04\\x08",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'stop\' : \'\\x00\',\'far_slow\' : \'\\x2a\',\'far_fast\' : \'\\x2b\',\'near_slow\' : \'\\x3a\',\'near_fast\' : \'\\x3b\'},\n                 \'description\':\'Focus Direct\'\n                },\n            \'gamma_mode\':\n                {\'getcmd\'    : "\\x04\\x51",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: \'auto\', 3: \'manual\'},\n                 \'setcmd\'    : "\\x01\\x04\\x51",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'auto\' : \'\\x02\',\'manual\' : \'\\x03\'},\n                 \'description\': \'Gamma mode. Default uses gamma table 4\'\n                },\n            \'gamma_table\':\n                {\'getcmd\'    : "\\x04\\x52",\n                 "gettype"   : "int16",\n                 \'setcmd\'    : "\\x01\\x04\\x52",\n                 \'settype\'   : \'int16\',\n                 \'setmin\'    : 0,\n                 \'setmax\'    : 7,\n                 \'description\': \'Gamma table. 0..7, default 4\'\n                },\n            \'gain\':\n                {\'setcmd\'    : "\\x01\\x04\\x4c",\n                 \'settype\'   : \'int16\',\n                 \'setmin\'    : 12,\n                 \'setmax\'    : 21,\n                 \'description\' : "Gain position, values: 12-21dB, only if AE mode manual"\n                },\n            \'hwid\':\n                {\'getcmd\'    : "\\x04\\x24",\n                 "gettype" : "string"\n                },\n            # \'id\':\n            #     {\'getcmd\'    : "\\x04\\x22",\n            #      "gettype" : "id"\n            #     },\n            \'iris\':\n                {\'setcmd\'    : "\\x01\\x04\\x75",\n                 \'settype\'   : \'int16\',\n                 \'setmin\'    : 0,\n                 \'setmax\'    : 40,\n                 \'description\' : "Iris position, range 0..50, only if AE mode manual"\n                },\n            \'IR_receive\':\n                {\'getcmd\'    : "\\x06\\x08",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: \'on\', 3: \'true\'}\n                },\n            \'mirror\':\n                {\'getcmd\'    : "\\x04\\x61",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: \'reversed\', 3: \'normal\'},\n                 \'setcmd\'    : "\\x01\\x04\\x61",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'reversed\' : \'\\x02\',\'normal\' : \'\\x03\', \'mirror\': \'\\x02\'},\n                 \'description\': \'Mirror image\'\n                },\n            \'motor_moved\':\n                {\'setcmd\'   : "\\x01\\x50\\x30",\n                 \'settype\'  : \'enum\',\n                 \'setattr\'  : {\'on\': "\\x01", \'off\': "\\x00"},\n                 \'description\':\'Motor movement detection, detect and reset position if on\'\n                },\n            \'pan_tilt\':\n                {\'getcmd\'    : "\\x06\\x12",\n                 "gettype"   : "int16int16",\n                 \'setcmd\'    : "\\x01\\x06\\x02\\x01\\x01",\n                 \'settype\'   : "int16int16",\n                 \'description\':\'pan tilt direct control\'\n                },\n            \'pan_tilt_ctl\':\n                {\'setcmd\'    : "\\x01\\x06",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {    \'stop\'      : \'\\x01\\x03\\x03\\x03\\x03\',\n                                    \'reset\'     : \'\\x05\',\n                                    \'up\'        : \'\\x01\\x03\\x03\\x03\\x01\',\n                                    \'down\'      : \'\\x01\\x03\\x03\\x03\\x02\',\n                                    \'left\'      : \'\\x01\\x03\\x03\\x01\\x03\',\n                                    \'right\'     : \'\\x01\\x03\\x03\\x02\\x03\',\n                                    \'up_left\'   : \'\\x01\\x03\\x03\\x01\\x01\',\n                                    \'up_right\'  : \'\\x01\\x03\\x03\\x02\\x01\',\n                                    \'down_left\' : \'\\x01\\x03\\x03\\x01\\x02\',\n                                    \'down_right\': \'\\x01\\x03\\x03\\x02\\x02\',\n                                },\n                 \'description\':\'Pan Tilt Controller\'\n                 },\n            \'power_led\':\n                {\'getcmd\'   : "\\x01\\x33\\x02",\n                 "gettype"  : "enum",\n                 "getattr"  : {2: \'on\', 3: \'off\'},\n                 \'setcmd\'   : "\\x01\\x33\\x02",\n                 \'settype\'  : \'enum\',\n                 \'setattr\'  : {\'on\': "\\x01", \'off\': "\\x00"}\n                },\n            \'power\':\n                {\'getcmd\'    : "\\x04\\x00",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: \'on\', 3: \'off\'},\n                 \'setcmd\'    : "\\x01\\x04\\x00",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'on\': "\\x02", \'off\': "\\x03"}\n                },\n            \'swid\':\n                {\'getcmd\'    : "\\x04\\x23",\n                 "gettype" : "string"\n                },\n            \'upside_down\':\n                {\'getcmd\'    : "\\x50\\x70",\n                 "gettype" : "enum",\n                 "getattr"   : {2: \'no\', 3: \'yes\'}\n                },\n            \'version\':\n                {\'getcmd\'    : "\\x00\\x02",\n                },\n            \'video\':\n                {\'getcmd\'    : "\\x06\\x23",\n                 "gettype"   : "enum16",\n                 "getattr"   : {0: \'1080p25\', 1: \'1080p30\', 2: \'1080p50\', 3: \'1080p60\', 4: \'720p25\', 5: \'720p30\', 6: \'720p50\', 7: \'720p60\'},\n                 \'setcmd\'    : "\\x01\\x35\\x00",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'1080p25\': \'\\x00\\x00\',  \'1080p30\': \'\\x00\\x01\', \'1080p50\': \'\\x00\\x02\',  \'1080p60\': \'\\x00\\x03\',  \'720p25\': \'\\x00\\x04\',  \'720p30\': \'\\x00\\x05\',  \'720p50\': \'\\x00\\x06\',  \'720p60\': \'\\x00\\x07\'}\n                },\n            \'WB_mode\':\n                {\'getcmd\'    : "\\x04\\x35",\n                 "gettype"   : "enum",\n                 "getattr"   : {2: \'auto\', 6: \'table\'},\n                 \'setcmd\'    : "\\x01\\x04\\x35",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'auto\' : \'\\x00\',\'table\' : \'\\x06\'}\n                },\n            \'WB_table\':\n                {\'getcmd\'    : "\\x04\\x75",\n                 "gettype"   : "int16",\n                 \'setcmd\'    : "\\x01\\x04\\x75",\n                 \'settype\'   : \'int16\',\n                },\n            \'zoom\':\n                {\'getcmd\'    : "\\x04\\x47",\n                 "gettype"   : "int16",\n                 \'setcmd\'    : "\\x01\\x04\\x47",\n                 \'settype\'   : \'int16\',\n                 \'setmin\'    : 0,\n                 \'setmax\'    : 2885,\n                 \'description\':\'Zoom Direct (Wide: 0.. Tele: 2885)\'\n                },\n            \'zoom_ctl\':\n                {\'setcmd\'    : "\\x01\\x04\\x07",\n                 \'settype\'   : \'enum\',\n                 \'setattr\'   : {\'stop\' : \'\\x00\',\'tele_slow\' : \'\\x2a\',\'tele_fast\' : \'\\x2b\',\'wide_slow\' : \'\\x3a\',\'wide_fast\' : \'\\x3b\'},\n                 \'description\':\'Zoom Controller\'\n                },\n\n}\n            # \'aperture\':     "\\x04\\x42",\n            # \'bright\':       "\\x04\\x4D",\n            # \'chromasuppress\':"\\x04\\x5F",\n            # \'color_gain\':   "\\x04\\x49",\n            # \'color_hue\':    "\\x04\\x4F",\n            # \'condition\':    "\\x06\\x34",\n            # \'expo_compensation_amount\':"\\x04\\x4E",\n            # \'expo_compensation\':"\\x04\\x3E",\n            # \'fan\':          "\\x7E\\x01\\x38",\n            # \'FX\':           "\\x04\\x63",\n            # \'gain_blue\':    "\\x04\\x44",\n            # \'gain_limit\':   "\\x04\\x2C",\n            # \'gain_red\':     "\\x04\\x43",\n            # \'gain\':         "\\x04\\x4C",\n            # \'gamma\':        "\\x04\\x5B",\n            # \'high_sensitivity\':"\\x04\\x5E",\n            # \'HR\':           "\\x04\\x52",\n            # \'info_display\': "\\x7E\\x01\\x18",\n            # \'IR_auto_threshold\':"\\x04\\x21",\n            # \'IR_auto\':      "\\x04\\x51",\n            # \'IR_receive\':   "\\x06\\x08",\n            # \'IR\':           "\\x04\\x01",\n            # \'iris\':         "\\x04\\x4B",\n            # \'NR\':           "\\x04\\x53",\n            # \'pan_tilt_mode\':"\\x06\\x10",\n            # \'pan_tilt_speed\':"\\x06\\x11",\n            # \'shutter\':      "\\x04\\x4A",\n            # \'slowshutter\':  "\\x04\\x5A",\n            # \'video_next\':   "\\x06\\x33",\n            # \'WD\':           "\\x04\\x3D",\n            # \'zoom_digital\': "\\x04\\x06",\n            # \'focus_auto_mode\':"\\x04\\x57",\n            # \'focus_auto_sensitivity\':"\\x04\\x58",\n            # \'focus_ir\':     "\\x04\\x11",\n            # \'focus_nearlimit\':"\\x04\\x28",\n\n#\n# getattrs = {\n#             \'AE\':           {0: \'auto\', 3: \'manual\', 10: \'shutter\', 11: \'iris\', 13: \'bright\'},\n#             \'backlight\':    {2: \'On\', 3: \'Off\', 4: \'Auto\'},\n#             \'call_led\':     {2: \'On\', 3: \'Off\', 4: \'Blink\'},\n#             \'flip\':         {2: True, 3: False},\n#             \'focus_auto\':   {2: True, 3: False},\n#             \'IR_receive\':   {2: True, 3: False},\n#             \'mirror\':       {2: True, 3: False},\n#             \'power_led\':    {2: True, 3: False},\n#             \'power\':        {2: True, 3: False},\n#             \'upside_down\':  {0: False, 1: True},\n#             \'video\':        {0: \'1080p25\', 1: \'1080p30\', 2: \'1080p50\', 3: \'1080p60\', 4: \'720p25\', 5: \'720p30\', 6: \'720p50\', 7: \'720p60\'},\n#             \'WB\':           {0: \'auto\', 1: \'indoor\', 2: \'outdoor\', 3: \'trigger\', 5: \'manual\'},\n#             #                     12:300, 11:215, 10:150, 9:120, 8:100, 7:75, 6:50, 5:25, 4:12, 3:6, 2:3, 1:2, 0:1},\n#             #                     17:1750, 16:1250 , 15:1000, 14:600, 13:425,\n#             # \'expo_compensation_amount\':{14:10.5, 13:9, 12:7.5, 11:6, 10:4.5, 9:3, 8:1.5, 7:0, 6:-1.5, 5:-3, 4:-4.5, 3:-6, 2:-7.5, 1:-9, 0:-10.5}, \\\n#             # \'expo_compensation\':{2:True,3:False},\n#             # \'fan\':          {0:True, 1:False},\n#             # \'focus_auto_mode\':{0:\'normal\', 1:\'interval\', 2:\'zoom_trigger\'},\n#             # \'focus_auto_sensitivity\':{2:\'normal\', 3:\'low\'},\n#             # \'focus_ir\':     {2:True,3:False},\n#             # \'FX\':           {0:\'normal\', 2:\'negart\', 4:\'BW\'},\n#             # \'gain_limit\':   {4:+6, 5:+8, 6:+10, 7:+12, 8:+14, 9:+16, 10:+18, 11:+20, 12:+22, 13:+24, 14:+26, 15:+28}, \\\n#             # \'gain\':         {0:-3, 1:0, 3:+2, 3:+4, 4:+6, 5:+8, 6:+10, 7:+12, 8:+14, 9:+16, 10:+18, 11:+20, 12:+22, 13:+24, 14:+26, 15:+28}, \\\n#             # \'high_sensitivity\':{2:True,3:False},\n#             # \'HR\':           {2:True,3:False},\n#             # \'info_display\': {2:True,3:False},\n#             # \'IR_auto\':      {2:True,3:False},\n#             # \'IR\':           {2:True,3:False},\n#             # \'iris\':         {17:1.6, 16:2, 15:2.4, 14:2.8, 13:3.4, 12:4, 11:4.8, 10:5.6, 9:6.8, 8:8, 7:9.6, 6:11, 5:14, 0:0},\n#             # \'shutter\':      {21:10000, 20:6000, 19:3500, 18:2500,\n#             # \'slowshutter\':  {2:\'auto\', 3:\'manual\'},\n#             # \'video_next\':   {0:\'1080i59.95\', 1:\'1080p29.97\', 2:\'720p59.94\', 3:\'720p29.97\', 4:\'NTSC\', 8:\'1080i50\', 9:\'720p50\', 10:\'720p25\', 11:\'1080i50\', 12:\'PAL\'},\n#             # \'WD\':           {2:True,3:False},\n#             # \'zoom_digital\': {2:True,3:False},\n#             # \'video\':        {0:\'1080i59.95\', 1:\'1080p29.97\', 2:\'720p59.94\', 3:\'720p29.97\', 4:\'NTSC\', 8:\'1080i50\', 9:\'720p50\', 10:\'720p25\', 11:\'1080i50\', 12:\'PAL\'}, \\\n#\n#             }\n\n# high_res_params = [\'shutter\', \'iris\', \'gain\', \'gain_limit\', \'gain_red\', \'gain_blue\',\n#     \'bright\', \'expo_compensation_amount\', \'aperture\', \'IR_auto_threshold\']\n#\n# very_high_res_params = [\'zoom\', \'focus\',\n#     \'focus_nearlimit\', \'focus_auto_interval\', \'ID\']\n''')
    __stickytape_write_module('''pyviscam/__init__.py''', '''#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n"""\nThis module allows you to control video camera through Visca protocol\n\n-------------------------------------------------------------------------------\n\n    Copyright (c) 2016 Pixel Stereo\n\n-------------------------------------------------------------------------------\nChangelog:\n-------------------------------------------------------------------------------\n- v0.0.5  -\n    - Many Bug Fixes\n    - Add Error codes for all serial operations\n\n- v0.0.1  -  Mar. 26th 2016\n    - First draft\n"""\n\ndebug = 5\n''')
    __stickytape_write_module('''pyviscam/broadcast.py''', '''#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\n"""\nBroadcast module contains Viscam Class\nViscam is the first object to create\n\nTypically, it can be done with :\n\nfrom pyviscam.broadcast import Viscam\ncams = Viscam()\n# choose the first serial port available\nport = cams.serial.listports()[0]\n# reset method will ask about cameras on this line\ncams.reset(port)\n# this is the list of the camera found on this serial port\ncams = cams.get_instances()\n# go to home (for pan_tilt camera)\ncams[0].home()\n# Set Automatic Exposure\ncams[0].AE = \'auto\'\n# ask about the White Balance\ncams[0].query(\'WB\')\n\n"""\n\nimport sys,logging\nfrom pyviscam.port import Serial\nfrom pyviscam.camera import Camera\n\nfrom pyviscam import debug\nimport hexdump\n\nclass Viscam(object):\n    """\n    Viscam is a chain of Visca camera\n    Viscam is a broadcast command relative to a Serial port\n    Viscam initialisation call _cmd_address_set and _if_clear\n    """\n    def __init__(self, port=None):\n        super(Viscam, self).__init__()\n        # create a serial port communication\n        serial = Serial()\n        # make it available from everywhere\n        self.serial = serial\n        self.port = port\n        if port:\n            self.reset(port)\n        else:\n            logging.debug("ERROR 34 - no serial port selected")\n\n    def get_instances(self):\n        """\n        Get instances of Camera Objects\n        """\n        return self.viscams\n\n    def reset(self, port):\n        """\n        Reset the visca communication\n        Notice that it release and re-create Visca objects\n        """\n        # if there is a port, open it\n        self.serial.open(port)\n        # Give me the list of available cameras\n        self.viscams = self._cmd_adress_set()\n        # Clear the buffers from any packet stuck anywhere\n        #self._if_clear()\n\n    def _send_broadcast(self, data):\n        """\n        shortcut to broadcast commands\n        """\n        return self._send_packet(data, -1)\n\n    def _cmd_adress_set(self):\n        """\n        starts enumerating devices, sends the first adress to use on the bus\n        reply is the same packet with the next free adress to use\n\n        Create Visca Instances for each device found on the serial bus\n        """\n        #address of first device. should be 1:\n        first = 1\n\n        reply = self._send_broadcast(\'\\x30\'+chr(first)) # set address\n        if isinstance(reply, type(None)):\n            logging.debug("ERROR 35 - No reply from the bus")\n            sys.exit(1)\n        if len(reply) != 4 or reply[-1:] != \'\\xff\':\n            logging.debug("ERROR 36 - enumerating devices %s",reply[:-1])\n            sys.exit(1)\n        if reply[0] != \'\\x88\':\n            logging.debug("ERROR 37 - expecting broadcast answer to an enumeration request")\n            sys.exit(1)\n        address = ord(reply[2])\n\n        devices_count = address - first\n        if devices_count == 0:\n            logging.debug(\'ERROR 38 - unexpected answer : someone reply, but no Camera found\')\n            sys.exit(1)\n        else:\n            logging.debug("found %i devices on the bus",devices_count)\n            device = 1\n            viscams = []\n            while device <= devices_count:\n                device = device + 1\n                cam = Camera(self)\n                viscams.append(cam)\n            return viscams\n\n    def _if_clear(self):\n        """\n        clear the interfaces on the bys\n        """\n        # interface clear all\n        reply = self._send_broadcast(\'\\x01\\x00\\x01\')\n        if not reply[1:] == \'\\x01\\x00\\x01\\xff\':\n            logging.error("ERROR 39 - when clearing interfaces on the bus!")\n            sys.exit(1)\n        logging.debug("all interfaces clear")\n        return reply\n\n    def _send_packet(self, data, recipient=1):\n        """\n        according to the documentation:\n\n        |------packet (3-16 bytes)---------|\n\n         header     message      terminator\n         (1 byte)  (1-14 bytes)  (1 byte)\n\n        | X | X . . . . .  . . . . . X | X |\n\n        header:                  terminator:\n        1 s2 s1 s0 0 r2 r1 r0     0xff\n\n        with r,s = recipient, sender msb first\n\n        for broadcast the header is 0x88!\n\n        we use -1 as recipient to send a broadcast!\n        """\n        # we are the controller with id=0\n        sender = 0\n        if recipient == -1:\n            #broadcast:\n            rbits = 0x8\n        else:\n            # the recipient (address = 3 bits)\n            rbits = recipient & 0b111\n\n        sbits = (sender & 0b111)<<4\n        header = 0b10000000 | sbits | rbits\n        terminator = 0xff\n        packet = chr(header)+data+chr(terminator)\n        logging.debug("Send: %s",hexdump.dump(packet))\n        self.serial.mutex.acquire()\n        self.serial._write_packet(packet)\n        reply = self.serial.recv_packet()\n        logging.debug("Received: %s",hexdump.dump(reply))\n        if reply:\n            if reply[-1:] != \'\\xff\':\n                logging.debug("received packet not terminated correctly: %s" ,reply.encode(\'hex\'))\n                reply = None\n            self.serial.mutex.release()\n            return reply\n        else:\n            return None\n''')
    __stickytape_write_module('''pyviscam/camera.py''', '''#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\n"""\nThis file contains the Camera class that represent a camera device\nYou don\'t have to create this class by yourself as it is done for each device\nthat answers to a broadcast message.\n\n"""\nfrom pyviscam.port import Serial\n# from pyviscam.convert import hex_to_int, i2v, scale\n# from pyviscam.pan_tilt_utils import degree_to_visca, visca_to_degree\nfrom pyviscam.constants import commands\n\nfrom pyviscam import debug\nimport hexdump\nimport re\nimport logging,sys\n\nclass Camera(object):\n    """\n    create a visca camera\n    """\n    def __init__(self, parent, port=None,id=1):\n        """the constructor"""\n        if port==None:\n            self.serial = parent.serial\n            self.parent = parent\n            logging.debug("new visca camera")\n        else:\n            serial = Serial()\n            self.serial = serial\n            self.port = port\n            self.id   = id\n            if not self.serial.open(port):\n                logging.error("Failed to open port %s, bailing",port)\n                return None\n\n    def __getattr__(self, name):\n        cmdget = self._get(name)\n        if cmdget == None:\n            return super(Camera, self).__getattr__(name, value)\n        else:\n            return cmdget\n\n    def __setattr__(self, name, value,value2=None):\n        cmdset = self._set(name,value,value2)\n        if cmdset == None:\n            super(Camera, self).__setattr__(name, value)\n        else:\n            return cmdset\n\n    def exists(self,name):\n        return name in commands\n\n    def describe(self,name):\n        if self.exists(name) and \'description\' in commands[name]:\n            return commands[name][\'description\']\n        else:\n            return \'\'\n\n    def _filter(self,key):\n        return [ a for a in commands if key in commands[a]]\n\n    def _hasattr(self,name,key):\n        return name in commands and key in commands[name]\n\n    def _getattr(self,name,key):\n        if self._hasattr(name,key):\n            return commands[name][key]\n        return None\n\n    def getters(self):\n        return self._filter(\'getcmd\')\n\n    def getter(self,name):\n        return self._hasattr(name,\'getcmd\')\n\n    def setters(self):\n        return self._filter(\'setcmd\')\n\n    def setter(self,name):\n        return self._hasattr(name,\'setcmd\')\n\n    def keys(self,name):\n        if self._hasattr(name,\'setattr\'):\n            return [ k for k in commands[name][\'setattr\']]\n        else:\n            return None\n\n    def allcmds(self):\n        return [ k for k in commands ]\n\n    def _send_packet(self, data, recipient=1):\n        """\n        according to the documentation:\n\n        |------packet (3-16 bytes)---------|\n\n         header     message      terminator\n         (1 byte)  (1-14 bytes)  (1 byte)\n\n        | X | X . . . . .  . . . . . X | X |\n\n        header:                  terminator:\n        1 s2 s1 s0 0 r2 r1 r0     0xff\n\n        with r,s = recipient, sender msb first\n\n        for broadcast the header is 0x88!\n\n        we use -1 as recipient to send a broadcast!\n\n        """\n        # we are the controller with id=0\n        sender = 0\n        if recipient == -1:\n            # broadcast\n            rbits = 0x8\n        else:\n            # the recipient (address = 3 bits)\n            rbits = recipient & 0b111\n        sbits = (sender & 0b111)<<4\n        header = 0b10000000 | sbits | rbits\n        terminator = 0xff\n        packet = chr(header)+data+chr(terminator)\n        logging.debug("Send: %s" % hexdump.dump(packet))\n        self.serial.mutex.acquire()\n        self.serial._write_packet(packet)\n        reply = self.serial.recv_packet()\n        logging.debug("Received: %s" % hexdump.dump(reply))\n        if reply:\n            if reply[-1:] != \'\\xff\':\n                logging.warning("ERROR 41 - received packet not terminated correctly: %s" % reply.encode(\'hex\'))\n                reply = None\n            self.serial.mutex.release()\n            return reply\n        else:\n            return None\n\n    def _cmd_cam_alt(self, subcmd):\n        """\n        shortcut to send command with alternative prefix\n        """\n        prefix = \'\\x01\\x06\'\n        self._cmd_cam(subcmd, prefix)\n\n    def _cmd_cam(self, subcmd, prefix=\'\'):\n        """\n        Send a command to the camera and return the answer\n        The camera answer first an acceptation of the command, and then a completion\n        If the command cannot be send or is not a valide command\n        => the camera will answers an error code\n        """\n        packet = prefix + subcmd\n        reply = self._send_packet(packet)\n\n        if reply.startswith(\'\\x90\'+\'\\x50\'):\n            if reply[-4:] == \'\\x00\\xFF\':\n                debugout = reply[4:][:-4].decode(\'hex\')\n                logging.debug(debugout)\n            logging.debug(\'-----------COMMAND COMPLETE-------------------\')\n            return True\n        if reply.startswith(\'\\x90\'+\'\\x90\'):\n            debugout = reply[2:][:-2]\n            logging.debug(debugout)\n            try:\n                while True:\n                    reply = self.serial.recv_packet()\n                    debugout = reply[2:][:-2]\n                    logging.debug(debugout)\n            except TimeoutError:\n                logging.debug(\'timed out\')\n            logging.debug(\'-----------COMMAND COMPLETE 9090-------------------\')\n            return True\n        if reply == \'\\x90\'+\'\\x41\'+\'\\xFF\':\n            logging.debug(\'-----------ACK 1-------------------\')\n            reply = self.serial.recv_packet()\n            if reply == \'\\x90\'+\'\\x51\'+\'\\xFF\':\n                logging.debug(\'--------COMPLETION 1---------------\')\n                return True\n        elif reply == \'\\x90\'+\'\\x42\'+\'\\xFF\':\n            logging.debug(\'-----------ACK 2-------------------\')\n            reply = self.serial.recv_packet()\n            if reply == \'\\x90\'+\'\\x52\'+\'\\xFF\':\n                logging.debug(\'--------COMPLETION 2---------------\')\n                return True\n        elif reply == \'\\x90\'+\'\\x60\'+\'\\x02\'+\'\\xFF\':\n            logging.warning(\'--------Syntax Error------------\')\n            return False\n        elif reply == \'\\x90\'+\'\\x60\'+\'\\x41\'+\'\\xFF\':\n            logging.warning(\'-----------ERROR 3 (not in this mode)------------\')\n            return False\n        elif reply == \'\\x90\'+\'\\x61\'+\'\\x41\'+\'\\xFF\':\n            logging.warning(\'-----------ERROR 1 (not in this mode)------------\')\n            return False\n        elif reply == \'\\x90\'+\'\\x62\'+\'\\x41\'+\'\\xFF\':\n            logging.warning(\'-----------ERROR 2 (not in this mode)------------\')\n            return False\n\n    def _come_back(self, query):\n        """\n        Send a query and wait for (ack + completion + answer)\n            :Accepts a visca query (hexadeciaml)\n            :Return a visca answer if ack and completion (hexadeciaml)\n        """\n        # send the query and wait for feedback\n        reply = self._send_packet(query)\n        if reply == \'\\x90\'+\'\\x60\'+\'\\x03\'+\'\\xFF\':\n            logging.info(\'-------- FULL BUFFER ---------------\')\n            # buffer is full, send it again\n            self._come_back(query)\n        elif reply.startswith(\'\\x90\'+\'\\x50\'):\n            logging.debug(\'-------- QUERY COMPLETION ---------------\')\n            # We know this is a valid query request, please send it back\n            return reply\n        elif reply == \'\\x90\'+\'\\x60\'+\'\\x02\'+\'\\xFF\':\n            logging.error(\'-------- QUERY SYNTAX ERROR ---------------\')\n            return False\n        elif reply == \'\\x90\'+\'\\x60\'+\'\\x41\'+\'\\xFF\':\n            logging.warning(\'-----------ERROR 3 (not in this mode)------------\')\n            return False\n        elif reply == \'\\x90\'+\'\\x61\'+\'\\x41\'+\'\\xFF\':\n            logging.warning(\'-----------ERROR 1 (not in this mode)------------\')\n            return False\n        elif reply == \'\\x90\'+\'\\x62\'+\'\\x41\'+\'\\xFF\':\n            logging.warning(\'-----------ERROR 2 (not in this mode)------------\')\n            return False\n\n\n    def parse_string(self,hexreply):\n        return re.sub(r\'^.050(.*)ff$\',r\'\\1\',hexreply).decode(\'hex\')\n\n    def parse_int4(self,hexreply):\n        return int(re.sub(r\'^.050.(.)ff\',r\'0x\\1\',hexreply),0)\n\n    def parse_int16(self,hexreply):\n        return int(re.sub(r\'^.050.(.).(.).(.).(.)ff\',r\'0x\\1\\2\\3\\4\',hexreply),0)\n\n    def parse_int32(self,hexreply):\n        return  int(re.sub(r\'^.050.(.).(.).(.).(.).(.).(.).(.).(.)ff\',r\'0x\\1\\2\\3\\4\\5\\6\\7\\8\',hexreply),0)\n\n    def parse_int16int16(self,hexreply):\n        return (int(re.sub(r\'^.050.(.).(.).(.).(.).(.).(.).(.).(.)ff\',r\'0x\\1\\2\\3\\4\',hexreply),0),\n                int(re.sub(r\'^.050.(.).(.).(.).(.).(.).(.).(.).(.)ff\',r\'0x\\5\\6\\7\\8\',hexreply),0))\n\n    def _get(self, function=None):\n        """\n        _get method needs a parameter as argument\n            :Return False if no parameter is provided\n            :Return False if parameter provided does not exist\n            :Return\n        """\n        if not function in commands:\n            return None\n\n        logging.debug(\'QUERY: %s\', function)\n\n        # transform the property into its code (located in the __init__file of the package)\n        if function in commands:\n            if \'getcmd\' in commands[function]:\n                subcmd = commands[function][\'getcmd\']\n            else:\n                logging.debug(\'ERROR XX - function %s has no getter\',function)\n                return False\n        else:\n            if debug:\n                # there is no code for this function\n                logging.debug(\'ERROR XX - function %s is not implemented\',function)\n            return False\n        # query starts with \'\\x09\'\n        query = \'\\x09\' + subcmd\n\n        # wait for the reply\n        if len(subcmd) > 0:\n            reply = self._come_back(query)\n        else:\n            reply = self.serial.recv_packet()\n        if reply:\n\n            hexreply = reply.encode(\'hex\')\n            reply_type = commands[function][\'gettype\']\n\n            if reply_type == \'enum\':\n                return commands[function][\'getattr\'][self.parse_int4(hexreply)]\n            elif reply_type == \'enum16\':\n                return commands[function][\'getattr\'][self.parse_int16(hexreply)]\n            elif reply_type == \'int16\':\n                return self.parse_int16(hexreply)\n            elif reply_type == \'int32\':\n                return self.parse_int32(hexreply)\n            elif reply_type == \'int16int16\':\n                return self.parse_int16int16(hexreply)\n            elif reply_type == \'string\':\n                return self.parse_string(hexreply)\n            else:\n                logging.error(\'FIX ME : is it normal that %s with type %s has no translation??\' , function,reply_type )\n\n    # def parse_string(self,hexreply):\n    #     return re.sub(r\'^.050(.*)ff$\',r\'\\1\',hexreply).decode(\'hex\')\n    #\n    # def parse_int4(self,hexreply):\n    #     return int(re.sub(r\'^.050.(.)ff\',r\'0x\\1\',hexreply),0)\n\n    def encode_int16(self,value):\n        hv = "%0.4X" % value\n        hs = "0%c0%c0%c0%c" % (hv[0],hv[1],hv[2],hv[3])\n        return hs.decode(\'hex\')\n\n    # def parse_int32(self,hexreply):\n    #     return  int(re.sub(r\'^.050.(.).(.).(.).(.).(.).(.).(.).(.)ff\',r\'0x\\1\\2\\3\\4\\5\\6\\7\\8\',hexreply),0)\n    #\n    # def parse_int16int16(self,hexreply):\n    #     return (int(re.sub(r\'^.050.(.).(.).(.).(.).(.).(.).(.).(.)ff\',r\'0x\\1\\2\\3\\4\',hexreply),0),\n    #             int(re.sub(r\'^.050.(.).(.).(.).(.).(.).(.).(.).(.)ff\',r\'0x\\5\\6\\7\\8\',hexreply),0))\n\n    def _set(self, function,value,value2=None):\n        """\n        _set method needs a function name and value as argument\n            :Return None if function not in commands\n            :Return False if value was not set\n            :Return True if value was set\n\n            :Raises NotImplementedError if setter doesn\'t exist for function\n            :Raises ValueError if value out of range or not defined\n        """\n\n        if not function in commands:\n            return None\n\n        logging.debug("setter: %s",function)\n\n        if function in commands:\n            if \'setcmd\' in commands[function]:\n                subcmd = commands[function][\'setcmd\']\n            else:\n                logging.error(\'setter: %s not implemented \',function,value)\n                raise NotImplementedError(\'setter: %s not implemented \' % function)\n\n        settype = commands[function][\'settype\']\n        if settype == \'enum\':\n            if value in commands[function][\'setattr\']:\n                cmd = subcmd + commands[function][\'setattr\'][value]\n            else:\n                logging.error(\'setter: %s key %s not found in setattr \',function,value)\n                raise ValueError("setter: %s key \'%s\' not found in setattr" % (function,value))\n\n        elif settype == \'int16\':\n            value = int(value)\n            if \'setmin\' in commands[function] and value < commands[function][\'setmin\']:\n                logging.error(\'setter: %s value %d < min (%d)\',function,value,commands[function][\'setmin\'])\n                raise ValueError("value %s out of range (min)" % function)\n            if \'setmax\' in commands[function] and value > commands[function][\'setmax\']:\n                logging.error(\'setter: %s value %d > max (%d)\',function,value,commands[function][\'setmax\'])\n                raise ValueError("value %s out of range (max)" % function)\n            cmd = subcmd + self.encode_int16(value)\n\n        elif settype == \'int16int16\':\n            value = int(value)\n            if value2 == None:\n                logging.error(\'setter: %s value2 not provided for int16int16\',function)\n                raise ValueError("%s value2 not provided for int16int16" % function)\n            value2 = int(value2)\n            if \'setmin\' in commands[function] and value < commands[function][\'setmin\']:\n                logging.error(\'setter: %s value %d < min (%d)\',function,value,commands[function][\'setmin\'])\n                raise ValueError("value %s out of range (min)" % function)\n            if \'setmax\' in commands[function] and value > commands[function][\'setmax\']:\n                logging.error(\'setter: %s value %d > max (%d)\',function,value,commands[function][\'setmax\'])\n                raise ValueError("value %s out of range (max)" % function)\n            if \'setmin1\' in commands[function] and value < commands[function][\'setmin2\']:\n                logging.error(\'setter: %s value %d < min (%d)\',function,value,commands[function][\'setmin2\'])\n                raise ValueError("value %s out of range (min)" % function)\n            if \'setmax2\' in commands[function] and value > commands[function][\'setmax2\']:\n                logging.error(\'setter: %s value %d > max (%d)\',function,value,commands[function][\'setmax2\'])\n                raise ValueError("value %s out of range (max)" % function)\n            cmd = subcmd + self.encode_int16(value)+self.encode_int16(value2)\n\n        elif settype == \'debug\':\n            logging.debug("sending debug %s",value)\n            cmd = subcmd + value+\'\\x0d\\x00\'\n            print self._cmd_cam(cmd)\n            try:\n                while True:\n                    reply = self.serial.recv_packet(line_end = True)\n                    if reply[:2] == "\\x90\\x90":\n                        reply = reply[2:]\n                    if reply[-2:] == "\\x00\\xff":\n                        reply = reply[:-2]\n                    sys.stdout.write(reply)\n            except RuntimeError:\n                    logging.debug(\'timed out\')\n            return\n\n        # elif settype == \'int32\':\n        #     return self.parse_int32(hexreply)\n        # elif settype == \'int16int16\':\n        #     return self.parse_int16int16(hexreply)\n        # elif settype == \'string\':\n        #     return self.parse_string(hexreply)\n        else:\n            logging.error(\'setter: %s type %s not implemented \',function,settype)\n            raise NotImplementedError(\'setter: %s type %s not implemented \' % function)\n\n        logging.debug("sending cmd %s" % cmd.encode(\'hex\'))\n\n        return self._cmd_cam(cmd)\n\n    # def home(self):\n    #     if debug:\n    #         print(\'home\')\n    #     subcmd = \'\\x04\'\n    #     return self._cmd_cam_alt(subcmd)\n    #\n    # def reset(self):\n    #     if debug:\n    #         print(\'reset\')\n    #     subcmd = \'\\x05\'\n    #     return self._cmd_cam_alt(subcmd)\n''')
    __stickytape_write_module('''pyviscam/port.py''', '''#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys,logging\nimport glob\nimport serial\ntry:\n    # python 2\n    from thread import allocate_lock\nexcept:\n    # python 3\n    from _thread import allocate_lock\n\nfrom pyviscam import debug\n\ndef listports():\n        """ Lists serial port names\n            :exit 1 (error code 11)\n                On unsupported or unknown platforms\n            :returns:\n                A list of the serial ports available on the system\n        """\n        if sys.platform.startswith(\'win\'):\n            ports = [\'COM%s\' % (i + 1) for i in range(256)]\n        elif sys.platform.startswith(\'linux\') or sys.platform.startswith(\'cygwin\'):\n            # this excludes your current terminal "/dev/tty"\n            ports = glob.glob(\'/dev/tty[A-Za-z]*\')\n        elif sys.platform.startswith(\'darwin\'):\n            from fnmatch import fnmatch\n            ports = [ n for n in glob.glob(\'/dev/tty.*\') if not fnmatch(n, \'*Bluetooth*\')]\n        else:\n            logging.error(\'ERROR 11 - Unsupported platform\')\n            sys.exit(1)\n        result = []\n        for port in ports:\n            try:\n                s = serial.Serial(port)\n                s.close()\n                result.append(port)\n            except (OSError, serial.SerialException):\n                pass\n        return result\n\nclass Serial(object):\n    def __init__(self):\n        self.mutex = allocate_lock()\n        self.port = None\n\n    def listports(self):\n        """ Lists serial port names\n            :exit 1 (error code 11)\n                On unsupported or unknown platforms\n            :returns:\n                A list of the serial ports available on the system\n        """\n        if sys.platform.startswith(\'win\'):\n            ports = [\'COM%s\' % (i + 1) for i in range(256)]\n        elif sys.platform.startswith(\'linux\') or sys.platform.startswith(\'cygwin\'):\n            # this excludes your current terminal "/dev/tty"\n            ports = glob.glob(\'/dev/tty[A-Za-z]*\')\n        elif sys.platform.startswith(\'darwin\'):\n            ports = glob.glob(\'/dev/tty.*\')\n        else:\n            logging.error(\'ERROR 11 - Unsupported platform\')\n            sys.exit(1)\n        result = []\n        for port in ports:\n            try:\n                s = serial.Serial(port)\n                s.close()\n                result.append(port)\n            except (OSError, serial.SerialException):\n                pass\n        return result\n\n    def open(self, portname):\n        self.mutex.acquire()\n        self.portname = portname\n        if (self.port == None):\n            try:\n                self.port = serial.Serial(self.portname, 9600, timeout=4, stopbits=1, \\\n                                          bytesize=8, rtscts=False, dsrdtr=False)\n                self.port.flushInput()\n                self.mutex.release()\n                return True\n            except:\n                self.port = None\n                self.mutex.release()\n                return False\n\n    def recv_packet(self, extra_title=None,line_end=False):\n        if self.port:\n            # read up to 16 bytes until 0xff\n            packet=\'\'\n            count=0\n            while count<128:\n                s=self.port.read(1)\n                if s:\n                    byte = ord(s)\n                    count+=1\n                    packet=packet+chr(byte)\n                else:\n                    if len(packet) >0:\n                        return packet\n                    logging.warning("ERROR 12 - Timeout waiting for reply")\n                    raise RuntimeError("ERROR 12 - Timeout waiting for reply")\n                    break\n                if byte==0xff:\n                    break\n                if byte==0x0a and line_end:\n                    break\n            return packet\n        else:\n            return False\n\n    def _write_packet(self, packet):\n        if self.port:\n            if not self.port.isOpen():\n                logging.error("ERROR 14 - no serial port cannot be opened")\n                return False\n            # lets see if a completion message or someting\n            # else waits in the buffer. If yes dump it.\n            elif self.port.inWaiting():\n                self.recv_packet("ignored")\n            self.port.write(packet)\n            return True\n        else:\n            logging.error("ERROR 15 - no serial port")\n            return False\n''')
    #!/usr/bin/env python
    #
    # import modules used here -- sys is a very standard one
    import sys, argparse, logging
    from pyviscam.broadcast import Viscam, Camera
    from pyviscam.port import listports

    def describe(cam,c):
          print c.ljust(12),
          if cam.setter(c):
              print " set",
          else:
              print "    ",
          if cam.getter(c):
              print " get",
          else:
              print "    ",
          if cam._hasattr(c,"settype"):
              print cam._getattr(c,"settype").rjust(10),
          else:
              print "".rjust(10),
          print " %s" % cam.describe(c),
          opts = cam.keys(c)
          if opts:
              print "(",
              print ','.join(opts),
              print ")",
          print ''

    # Gather our code in a main() function
    def main(args, loglevel):
      logging.basicConfig(format="%(levelname)s: %(message)s", level=loglevel)

      #cams = Viscam(port=args.port)
      cam  = Camera(None,port=args.port,id=1)

      cmd = args.command

      if cmd == "list" or cmd == "help":
        lc = sorted(cam.allcmds(),key=lambda s: s.lower())
        for c in lc:
            describe(cam,c)
      elif args.args:  # there are args lets assume they are inputs to a setters
        arglist = args.args
        arg = arglist[0]
        if cam.exists(cmd):
            if (arg == "help" or arg == "?") and cmd != "debug_cmd":
                print describe(cam,cmd)
            else:
                if len(arglist) == 2:
                    ret = cam._set(cmd,arg,arglist[1])
                else:
                    ret = cam._set(cmd,arg)
                if cam.getter(cmd):
                    print cam._get(cmd)
        else:
            logging.error("No such command %s ",cmd)
      else:
        if cam.getter(cmd):
            print cam._get(cmd)
        else:
            logging.error("No such query %s ",cmd)

    # Standard boilerplate to call the main() function to begin
    # the program.
    if __name__ == '__main__':
      parser = argparse.ArgumentParser(
            description = "Sends commands and queries to attached VISCA camera",
            epilog = "As an alternative to the commandline, params can be placed in a file, one per line, and specified on the commandline like '%(prog)s @params.conf'.",
                    fromfile_prefix_chars = '@' )
      # TODO Specify your real parameters here.
      parser.add_argument("command",
                          help = "command to send",
                          metavar = "command")
      parser.add_argument("args",
                          nargs=argparse.REMAINDER,
                          help = "optional command arguments",
                          metavar = "args")
      parser.add_argument("-v",
                          "--verbose",
                          help="increase output verbosity",
                          action="store_true")
      ports = listports()
      if len(ports) == 0:
          parser.add_argument("-p",
                            "--port",
                            required=True,
                            help="specify serial port the camera(s) is connected to")
      else:
          parser.add_argument("-p",
                            "--port",
                            default=ports[0],
                            help="specify serial port the camera(s) is connected to (default = %s)" % ports[0])

      args = parser.parse_args()

      # Setup logging
      if args.verbose:
        loglevel = logging.DEBUG
      else:
        loglevel = logging.INFO

      main(args, loglevel)
